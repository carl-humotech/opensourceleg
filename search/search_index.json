{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"opensourceleg","text":"<p>An open-source software library for numerical computation, data acquisition, and control of lower-limb robotic prostheses.</p> <p> </p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>The easiest and quickest way to install the opensourceleg library is via pip:</p> <pre><code>pip install opensourceleg\n</code></pre> <p>If you plan on installing the opensourceleg library on a Raspberry Pi, we recommend using opensourcelegpi tool, which is a cloud-based CI tool used to build an up-to-date OS for a Raspberry Pi that can be used headless/GUI-less to control autonomous/remote robotic systems. This tool bundles the opensourceleg library and its dependencies into a single OS image, which can be flashed onto a microSD card and used to boot a Raspberry Pi. For more information, click here.</p>"},{"location":"#developing","title":"Developing","text":"<p>To modify, develop, or contribute to the opensourceleg library, we encourage you to install Poetry, which is a python packaging and dependency management tool. Once you have Poetry installed on your local machine, you can clone the repository and install the opensourceleg library by running the following commands:</p> <pre><code>git clone https://github.com/neurobionics/opensourceleg.git\ncd opensourceleg\n\npoetry install\npoetry shell\n</code></pre> <p>Finally, install the environment and the pre-commit hooks with</p> <pre><code>make install\n</code></pre> <p>You are now ready to start development on your project! The CI/CD pipeline will be triggered when you open a pull request, merge to main, or when you create a new release.</p> <p>To finalize the set-up for publishing to PyPI or Artifactory, see here. For activating the automatic documentation with MkDocs, see here. To enable the code coverage reports, see here.</p>"},{"location":"#releasing-a-new-version","title":"Releasing a new version","text":"<ul> <li>Create an API Token on PyPI.</li> <li>Add the API Token to your projects secrets with the name <code>PYPI_TOKEN</code> by visiting this page.</li> <li>Create a new release on Github.</li> <li>Create a new tag in the form <code>*.*.*</code>.</li> <li>For more details, see here.</li> </ul>"},{"location":"#license","title":"License","text":"<p>The opensourceleg library is licensed under the terms of the LGPL-v2.1 license. This license grants users a number of freedoms:</p> <ul> <li>You are free to use the opensourceleg library for any purpose.</li> <li>You are free to modify the opensourceleg library to suit your needs.</li> <li>You can study how the opensourceleg library works and change it.</li> <li>You can distribute modified versions of the opensourceleg library.</li> </ul> <p>The GPL license ensures that all these freedoms are protected, now and in the future, requiring everyone to share their modifications when they also share the library in public.</p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#opensourceleg.actuators.ActuatorBase","title":"<code>ActuatorBase</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>class ActuatorBase(ABC):\n    def __init__(\n        self,\n        tag: str,\n        gear_ratio: float,\n        motor_constants: MOTOR_CONSTANTS,\n        frequency: int = 1000,\n        offline: bool = False,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        self._MOTOR_CONSTANTS: MOTOR_CONSTANTS = motor_constants\n        self._gear_ratio: float = gear_ratio\n        self._tag: str = tag\n        self._frequency: int = frequency\n        self._data: Any = None\n        self._is_offline: bool = offline\n        self._is_homed: bool = False\n\n        self._mode: CONTROL_MODES = CONTROL_MODES.IDLE\n\n        self._motor_zero_position: float = 0.0\n        self._motor_position_offset: float = 0.0\n\n        self._joint_zero_position: float = 0.0\n        self._joint_position_offset: float = 0.0\n        self._joint_direction: int = 1\n\n        self._is_open: bool = False\n        self._is_streaming: bool = False\n\n        self._original_methods: dict[str, MethodWithRequiredModes] = {}\n\n        self._set_original_methods()\n        self._set_mutated_methods()\n\n    def __enter__(self) -&gt; \"ActuatorBase\":\n        self.start()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, exc_traceback: Any) -&gt; None:\n        self.stop()\n\n    def _restricted_method(self, method_name: str, *args: Any, **kwargs: Any) -&gt; None:\n        LOGGER.error(f\"{method_name}() is not available in {self._mode.name} mode.\")\n        return None\n\n    def _set_original_methods(self) -&gt; None:\n        for method_name in CONTROL_MODE_METHODS:\n            try:\n                method = getattr(self, method_name)\n                if callable(method) and hasattr(method, \"_required_modes\"):\n                    self._original_methods[method_name] = method\n            except AttributeError:\n                LOGGER.debug(msg=f\"[{self.tag}] {method_name}() is not implemented in {self.tag}.\")\n\n    def _set_mutated_methods(self) -&gt; None:\n        for method_name, method in self._original_methods.items():\n            if self._mode in method._required_modes:\n                setattr(self, method_name, method)\n            else:\n                setattr(self, method_name, partial(self._restricted_method, method_name))\n\n    @property\n    @abstractmethod\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        pass\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def update(self) -&gt; None:\n        pass\n\n    def _get_control_mode_config(self, mode: CONTROL_MODES) -&gt; Optional[ControlModeConfig]:\n        return cast(\n            Optional[ControlModeConfig],\n            getattr(self._CONTROL_MODE_CONFIGS, mode.name),\n        )\n\n    def set_control_mode(self, mode: CONTROL_MODES) -&gt; None:\n        if self.mode == mode:\n            LOGGER.debug(msg=f\"[{self.tag}] Already in {self.mode.name} control mode.\")\n            return\n\n        current_config = self._get_control_mode_config(self.mode)\n        if current_config:\n            current_config.exit_callback(self)\n\n        self._mode = mode\n\n        new_config = self._get_control_mode_config(self.mode)\n        if new_config:\n            new_config.entry_callback(self)\n\n        self._set_mutated_methods()\n\n    @abstractmethod\n    @requires(CONTROL_MODES.VOLTAGE)\n    def set_motor_voltage(self, value: float) -&gt; None:\n        pass\n\n    @abstractmethod\n    @requires(CONTROL_MODES.CURRENT)\n    def set_motor_current(self, value: float) -&gt; None:\n        pass\n\n    @abstractmethod\n    @requires(CONTROL_MODES.POSITION)\n    def set_motor_position(self, value: float) -&gt; None:\n        pass\n\n    @requires(\n        CONTROL_MODES.POSITION\n    )  # This needs to be tested as set_motor_position is already decorated with requires\n    def set_output_position(self, value: float) -&gt; None:\n        self.set_motor_position(value=value * self.gear_ratio)\n\n    @abstractmethod\n    @requires(CONTROL_MODES.TORQUE)\n    def set_motor_torque(self, value: float) -&gt; None:\n        pass\n\n    @abstractmethod\n    @requires(CONTROL_MODES.TORQUE)\n    def set_joint_torque(self, value: float) -&gt; None:\n        pass\n\n    @abstractmethod\n    @requires(CONTROL_MODES.CURRENT)\n    def set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        pass\n\n    @abstractmethod\n    @requires(CONTROL_MODES.POSITION)\n    def set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        pass\n\n    @abstractmethod\n    @requires(CONTROL_MODES.IMPEDANCE)\n    def set_impedance_gains(self, kp: float, ki: float, kd: float, k: float, b: float, ff: float) -&gt; None:\n        pass\n\n    @abstractmethod\n    def home(self) -&gt; None:\n        pass\n\n    def set_motor_zero_position(self, value: float) -&gt; None:\n        \"\"\"Sets motor zero position in radians\"\"\"\n        self._motor_zero_position = value\n\n    def set_motor_position_offset(self, value: float) -&gt; None:\n        \"\"\"Sets joint offset position in radians\"\"\"\n        self._motor_position_offset = value\n\n    def set_joint_zero_position(self, value: float) -&gt; None:\n        \"\"\"Sets joint zero position in radians\"\"\"\n        self._joint_zero_position = value\n\n    def set_joint_position_offset(self, value: float) -&gt; None:\n        \"\"\"Sets joint offset position in radians\"\"\"\n        self._joint_position_offset = value\n\n    def set_joint_direction(self, value: int) -&gt; None:\n        \"\"\"Sets joint direction to 1 or -1\"\"\"\n        self._joint_direction = value\n\n    @property\n    @abstractmethod\n    def motor_position(self) -&gt; float:\n        pass\n\n    @property\n    def output_position(self) -&gt; float:\n        \"\"\"\n        Position of the output in radians.\n        This is calculated by scaling the motor angle with the gear ratio.\n        Note that this method does not consider compliance from an SEA.\n        \"\"\"\n        return self.motor_position / self.gear_ratio\n\n    @property\n    @abstractmethod\n    def motor_velocity(self) -&gt; float:\n        pass\n\n    @property\n    def output_velocity(self) -&gt; float:\n        \"\"\"\n        Velocity of the output in radians.\n        This is calculated by scaling the motor angle with the gear ratio.\n        Note that this method does not consider compliance from an SEA.\n        \"\"\"\n        return self.motor_velocity / self.gear_ratio\n\n    @property\n    @abstractmethod\n    def motor_voltage(self) -&gt; float:\n        pass\n\n    @property\n    @abstractmethod\n    def motor_current(self) -&gt; float:\n        pass\n\n    @property\n    @abstractmethod\n    def motor_torque(self) -&gt; float:\n        pass\n\n    @property\n    def MOTOR_CONSTANTS(self) -&gt; MOTOR_CONSTANTS:\n        return self._MOTOR_CONSTANTS\n\n    @property\n    def mode(self) -&gt; CONTROL_MODES:\n        return self._mode\n\n    @property\n    def tag(self) -&gt; str:\n        return self._tag\n\n    @property\n    def is_homed(self) -&gt; bool:\n        return self._is_homed\n\n    @property\n    def frequency(self) -&gt; int:\n        return self._frequency\n\n    @property\n    def is_offline(self) -&gt; bool:\n        return self._is_offline\n\n    @property\n    def gear_ratio(self) -&gt; float:\n        return self._gear_ratio\n\n    @property\n    def max_case_temperature(self) -&gt; float:\n        return self._MOTOR_CONSTANTS.MAX_CASE_TEMPERATURE\n\n    @property\n    @abstractmethod\n    def case_temperature(self) -&gt; float:\n        pass\n\n    @property\n    @abstractmethod\n    def winding_temperature(self) -&gt; float:\n        pass\n\n    @property\n    def max_winding_temperature(self) -&gt; float:\n        return self._MOTOR_CONSTANTS.MAX_WINDING_TEMPERATURE\n\n    @property\n    def motor_zero_position(self) -&gt; float:\n        return self._motor_zero_position\n\n    @property\n    def motor_position_offset(self) -&gt; float:\n        return self._motor_position_offset\n\n    @property\n    def joint_zero_position(self) -&gt; float:\n        return self._joint_zero_position\n\n    @property\n    def joint_position_offset(self) -&gt; float:\n        return self._joint_position_offset\n\n    @property\n    def joint_direction(self) -&gt; int:\n        return self._joint_direction\n\n    @property\n    def is_open(self) -&gt; bool:\n        return self._is_open\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        return self._is_streaming\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ActuatorBase.output_position","title":"<code>output_position: float</code>  <code>property</code>","text":"<p>Position of the output in radians. This is calculated by scaling the motor angle with the gear ratio. Note that this method does not consider compliance from an SEA.</p>"},{"location":"modules/#opensourceleg.actuators.ActuatorBase.output_velocity","title":"<code>output_velocity: float</code>  <code>property</code>","text":"<p>Velocity of the output in radians. This is calculated by scaling the motor angle with the gear ratio. Note that this method does not consider compliance from an SEA.</p>"},{"location":"modules/#opensourceleg.actuators.ActuatorBase.set_joint_direction","title":"<code>set_joint_direction(value)</code>","text":"<p>Sets joint direction to 1 or -1</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_joint_direction(self, value: int) -&gt; None:\n    \"\"\"Sets joint direction to 1 or -1\"\"\"\n    self._joint_direction = value\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ActuatorBase.set_joint_position_offset","title":"<code>set_joint_position_offset(value)</code>","text":"<p>Sets joint offset position in radians</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_joint_position_offset(self, value: float) -&gt; None:\n    \"\"\"Sets joint offset position in radians\"\"\"\n    self._joint_position_offset = value\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ActuatorBase.set_joint_zero_position","title":"<code>set_joint_zero_position(value)</code>","text":"<p>Sets joint zero position in radians</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_joint_zero_position(self, value: float) -&gt; None:\n    \"\"\"Sets joint zero position in radians\"\"\"\n    self._joint_zero_position = value\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ActuatorBase.set_motor_position_offset","title":"<code>set_motor_position_offset(value)</code>","text":"<p>Sets joint offset position in radians</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_motor_position_offset(self, value: float) -&gt; None:\n    \"\"\"Sets joint offset position in radians\"\"\"\n    self._motor_position_offset = value\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ActuatorBase.set_motor_zero_position","title":"<code>set_motor_zero_position(value)</code>","text":"<p>Sets motor zero position in radians</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_motor_zero_position(self, value: float) -&gt; None:\n    \"\"\"Sets motor zero position in radians\"\"\"\n    self._motor_zero_position = value\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ActuatorConnectionException","title":"<code>ActuatorConnectionException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Actuator Connection Exception</p>"},{"location":"modules/#opensourceleg.actuators.ActuatorConnectionException--attributes","title":"Attributes","text":"<p>message (str): Error message</p> Source code in <code>opensourceleg/logging/exceptions.py</code> <pre><code>class ActuatorConnectionException(Exception):\n    \"\"\"Actuator Connection Exception\n\n    Attributes\n    ----------\n    message (str): Error message\n\n    \"\"\"\n\n    def __init__(self, tag: str) -&gt; None:\n        super().__init__(f\"{tag} is not connected\")\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ActuatorStreamException","title":"<code>ActuatorStreamException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Actuator Stream Exception</p>"},{"location":"modules/#opensourceleg.actuators.ActuatorStreamException--attributes","title":"Attributes","text":"<p>message (str): Error message</p> Source code in <code>opensourceleg/logging/exceptions.py</code> <pre><code>class ActuatorStreamException(Exception):\n    \"\"\"Actuator Stream Exception\n\n    Attributes\n    ----------\n    message (str): Error message\n\n    \"\"\"\n\n    def __init__(self, tag: str) -&gt; None:\n        super().__init__(f\"{tag} is not streaming, please call start() method before sending commands\")\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator","title":"<code>DephyActuator</code>","text":"<p>               Bases: <code>Device</code>, <code>ActuatorBase</code></p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>class DephyActuator(Device, ActuatorBase):  # type: ignore[no-any-unimported]\n    def __init__(\n        self,\n        tag: str = \"DephyActuator\",\n        firmware_version: str = \"7.2.0\",\n        port: str = \"/dev/ttyACM0\",\n        gear_ratio: float = 1.0,\n        baud_rate: int = 230400,\n        frequency: int = 500,\n        debug_level: int = 4,\n        dephy_log: bool = False,\n        offline: bool = False,\n        stop_motor_on_disconnect: bool = False,\n    ) -&gt; None:\n        ActuatorBase.__init__(\n            self,\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=DEPHY_ACTUATOR_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n        )\n\n        self._debug_level: int = debug_level if dephy_log else 6\n        self._dephy_log: bool = dephy_log\n\n        if self.is_offline:\n            self.port = port\n            self._is_streaming: bool = False\n            self._is_open: bool = False\n        else:\n            Device.__init__(\n                self,\n                firmwareVersion=firmware_version,\n                port=port,\n                baudRate=baud_rate,\n                stopMotorOnDisconnect=stop_motor_on_disconnect,\n            )\n\n        self._thermal_model: ThermalModel = ThermalModel(\n            temp_limit_windings=self.max_winding_temperature,\n            soft_border_C_windings=10,\n            temp_limit_case=self.max_case_temperature,\n            soft_border_C_case=10,\n        )\n        self._thermal_scale: float = 1.0\n\n        self._mode = CONTROL_MODES.IDLE\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.tag}[DephyLegacyActuator]\"\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return DEPHY_CONTROL_MODE_CONFIGS\n\n    @check_actuator_connection\n    def start(self) -&gt; None:\n        try:\n            self.open()\n            self._is_open = True\n        except OSError:\n            print(\"\\n\")\n            LOGGER.error(\n                msg=f\"[{self.__repr__()}] Need admin previleges to open the port '{self.port}'. \\n\\n \\\n                    Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n            )\n            os._exit(status=1)\n\n        self.start_streaming(self._frequency)\n        time.sleep(0.2)\n        self._is_streaming = True\n\n        self._data = self.read()\n        self.set_control_mode(CONTROL_MODES.VOLTAGE)\n\n    @check_actuator_stream\n    @check_actuator_open\n    def stop(self) -&gt; None:\n        self.stop_motor()\n        self.set_control_mode(mode=CONTROL_MODES.IDLE)\n        self._is_streaming = False\n        self._is_open = False\n        self.close()\n\n    def update(self) -&gt; None:\n        self._data = self.read()\n\n        self._thermal_model.T_c = self.case_temperature\n        self._thermal_scale = self._thermal_model.update_and_get_scale(\n            dt=1 / self.frequency,\n            motor_current=self.motor_current,\n        )\n        if self.case_temperature &gt;= self.max_case_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Case thermal limit {self.max_case_temperature} reached. \\\n                    Stopping motor.\"\n            )\n            # self.stop()\n            raise ThermalLimitException()\n\n        if self.winding_temperature &gt;= self.max_winding_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Winding thermal limit {self.max_winding_temperature} reached. \\\n                    Stopping motor.\"\n            )\n            raise ThermalLimitException()\n        # Check for thermal fault, bit 2 of the execute status byte\n        if self._data[\"status_ex\"] &amp; 0b00000010 == 0b00000010:\n            self.stop()\n            raise RuntimeError(\"Actpack Thermal Limit Tripped\")\n\n    def home(\n        self,\n        homing_voltage: int = 2000,\n        homing_frequency: Optional[int] = None,\n        homing_direction: int = -1,\n        joint_direction: int = -1,\n        joint_position_offset: float = 0.0,\n        motor_position_offset: float = 0.0,\n        current_threshold: int = 5000,\n        velocity_threshold: float = 0.001,\n    ) -&gt; None:\n        \"\"\"\n\n        This method homes the actuator and the corresponding joint by moving it to the zero position.\n        The zero position is defined as the position where the joint is fully extended. This method will\n        also load the encoder map if it exists. The encoder map is a polynomial that maps the encoder counts\n        to joint position in radians. This is useful for more accurate joint position estimation.\n        Args:\n            homing_voltage (int): Voltage in mV to use for homing. Default is 2000 mV.\n            homing_frequency (int): Frequency in Hz to use for homing. Default is the actuator's frequency.\n            homing_direction (int): Direction to move the actuator during homing. Default is -1.\n            joint_direction (int): Direction to move the joint during homing. Default is -1.\n            joint_position_offset (float): Offset in radians to add to the joint position. Default is 0.0.\n            motor_position_offset (float): Offset in radians to add to the motor position. Default is 0.0.\n            current_threshold (int): Current threshold in mA to stop homing the joint or actuator.\n                This is used to detect if the actuator or joint has hit a hard stop. Default is 5000 mA.\n            velocity_threshold (float): Velocity threshold in rad/s to stop homing the joint or actuator.\n                This is also used to detect if the actuator or joint has hit a hard stop. Default is 0.001 rad/s.\n\n        \"\"\"\n        is_homing = True\n        homing_frequency = homing_frequency if homing_frequency is not None else self.frequency\n\n        self.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n\n        self.set_motor_voltage(value=homing_direction * homing_voltage)  # mV, negative for counterclockwise\n\n        _motor_encoder_array = []\n        _joint_encoder_array = []\n\n        time.sleep(0.1)\n\n        try:\n            while is_homing:\n                self.update()\n                time.sleep(1 / homing_frequency)\n\n                _motor_encoder_array.append(self.motor_position)\n                _joint_encoder_array.append(self.joint_position)\n\n                if abs(self.output_velocity) &lt;= velocity_threshold or abs(self.motor_current) &gt;= current_threshold:\n                    self.set_motor_voltage(value=0)\n                    is_homing = False\n\n        except KeyboardInterrupt:\n            self.set_motor_voltage(value=0)\n            LOGGER.info(msg=f\"[{self.__repr__()}] Homing interrupted.\")\n            return\n        except Exception as e:\n            self.set_motor_voltage(value=0)\n            LOGGER.error(msg=f\"[{self.__repr__()}] Homing failed: {e}\")\n            return\n\n        self.set_motor_zero_position(value=self.motor_position)\n        self.set_joint_zero_position(value=self.joint_position)\n\n        time.sleep(0.1)\n        self.set_joint_direction(joint_direction)\n        self.set_motor_position_offset(motor_position_offset)\n        self.set_joint_position_offset(joint_position_offset)\n\n        self._is_homed = True\n        LOGGER.info(f\"[{self.__repr__()}] Homing complete.\")\n\n        if os.path.isfile(path=f\"./{self.tag}_encoder_map.npy\"):\n            coefficients = np.load(file=f\"./{self.tag}_encoder_map.npy\")\n            self.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=coefficients))\n        else:\n            LOGGER.debug(\n                msg=f\"[{self.__repr__()}] No encoder map found. Please call the make_encoder_map method \\\n                    to create one. The encoder map is used to estimate joint position more accurately.\"\n            )\n\n    def make_encoder_map(self, overwrite: bool = False) -&gt; None:\n        \"\"\"\n        This method makes a lookup table to calculate the position measured by the joint encoder.\n        This is necessary because the magnetic output encoders are nonlinear.\n        By making the map while the joint is unloaded, joint position calculated by motor position * gear ratio\n        should be the same as the true joint position.\n\n        Output from this function is a file containing a_i values parameterizing the map\n\n        Eqn: position = sum from i=0^5 (a_i*counts^i)\n\n        Author: Kevin Best\n                U-M Locolab | Neurobionics Lab\n                Gitub: tkevinbest, https://github.com/tkevinbest\n        \"\"\"\n\n        if not self.is_homed:\n            LOGGER.warning(msg=f\"[{self.__repr__()}] Please home the {self.tag} joint before making the encoder map.\")\n            return None\n\n        if os.path.exists(f\"./{self.tag}_encoder_map.npy\") and not overwrite:\n            LOGGER.info(msg=f\"[{self.__repr__()}] Encoder map exists. Skipping encoder map creation.\")\n            return None\n\n        self.set_control_mode(mode=CONTROL_MODES.CURRENT)\n        self.set_current_gains()\n        time.sleep(0.1)\n        self.set_current_gains()\n\n        self.set_joint_torque(value=0.0)\n        time.sleep(0.1)\n        self.set_joint_torque(value=0.0)\n\n        _joint_encoder_array = []\n        _output_position_array = []\n\n        LOGGER.info(\n            msg=f\"[{self.__repr__()}] Please manually move the {self.tag} joint numerous times through \\\n                its full range of motion for 10 seconds. \\n{input('Press any key when you are ready to start.')}\"\n        )\n\n        _start_time: float = time.time()\n\n        try:\n            while time.time() - _start_time &lt; 10:\n                LOGGER.info(\n                    msg=f\"[{self.__repr__()}] Mapping the {self.tag} \\\n                        joint encoder: {10 - time.time() + _start_time} seconds left.\"\n                )\n                self.update()\n                _joint_encoder_array.append(self.joint_encoder_counts)\n                _output_position_array.append(self.output_position)\n                time.sleep(1 / self.frequency)\n\n        except KeyboardInterrupt:\n            LOGGER.warning(msg=\"Encoder map interrupted.\")\n            return None\n\n        LOGGER.info(msg=f\"[{self.__repr__()}] You may now stop moving the {self.tag} joint.\")\n\n        _power = np.arange(4.0)\n        _a_mat = np.array(_joint_encoder_array).reshape(-1, 1) ** _power\n        _beta = np.linalg.lstsq(_a_mat, _output_position_array, rcond=None)\n        _coeffs = _beta[0]\n\n        self.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=_coeffs))\n\n        np.save(file=f\"./{self.tag}_encoder_map.npy\", arr=_coeffs)\n        LOGGER.info(msg=f\"[{self.__repr__()}] Encoder map saved to './{self.tag}_encoder_map.npy'.\")\n\n    def set_motor_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor torque in Nm. This is the torque that is applied to the motor rotor, not the joint or output.\n        Args:\n            value (float): The torque to set in Nm.\n        \"\"\"\n        self.set_motor_current(\n            value / self.MOTOR_CONSTANTS.NM_PER_MILLIAMP,\n        )\n\n    def set_joint_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the joint torque of the joint.\n        This is the torque that is applied to the joint, not the motor.\n\n        Args:\n            value (float): torque in N_m\n        \"\"\"\n        self.set_motor_torque(value=value / self.gear_ratio)\n\n    @deprecated_with_routing(alternative_func=set_joint_torque)\n    def set_output_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the output torque of the joint.\n        This is the torque that is applied to the joint, not the motor.\n\n        Args:\n            value (float): torque in N_m\n        \"\"\"\n        self.set_motor_torque(value=value / self.gear_ratio)\n\n    def set_motor_current(\n        self,\n        value: float,\n    ) -&gt; None:\n        \"\"\"\n        Sets the motor current in mA.\n\n        Args:\n            value (float): The current to set in mA.\n        \"\"\"\n        self.command_motor_current(value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_current)\n    def set_current(self, value: float) -&gt; None:\n        self.command_motor_current(value=int(value))\n\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor voltage in mV.\n\n        Args:\n            value (float): The voltage to set in mV.\n        \"\"\"\n        self.command_motor_voltage(value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_voltage)\n    def set_voltage(self, value: float) -&gt; None:\n        self.command_motor_voltage(value=int(value))\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor position in radians.\n        If in impedance mode, this sets the equilibrium angle in radians.\n\n        Args:\n            value (float): The position to set\n        \"\"\"\n        self.command_motor_position(\n            value=int(\n                (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n            ),\n        )\n\n    def set_position_gains(\n        self,\n        kp: float = DEFAULT_POSITION_GAINS.kp,\n        ki: float = DEFAULT_POSITION_GAINS.ki,\n        kd: float = DEFAULT_POSITION_GAINS.kd,\n        ff: float = DEFAULT_POSITION_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the position gains in arbitrary Dephy units.\n\n        Args:\n            kp (float): The proportional gain\n            ki (float): The integral gain\n            kd (float): The derivative gain\n            ff (float): The feedforward gain\n        \"\"\"\n        self.set_gains(\n            kp=int(kp),\n            ki=int(ki),\n            kd=int(kd),\n            k=0,\n            b=0,\n            ff=int(ff),\n        )\n\n    def set_current_gains(\n        self,\n        kp: float = DEFAULT_CURRENT_GAINS.kp,\n        ki: float = DEFAULT_CURRENT_GAINS.ki,\n        kd: float = DEFAULT_CURRENT_GAINS.kd,\n        ff: float = DEFAULT_CURRENT_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the current gains in arbitrary Dephy units.\n\n        Args:\n            kp (float): The proportional gain\n            ki (float): The integral gain\n            kd (float): The derivative gain\n            ff (float): The feedforward gain\n        \"\"\"\n        self.set_gains(\n            kp=int(kp),\n            ki=int(ki),\n            kd=int(kd),\n            k=0,\n            b=0,\n            ff=int(ff),\n        )\n\n    def set_output_impedance(\n        self,\n        kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n        ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n        kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n        k: float = 100.0,\n        b: float = 3.0,\n        ff: float = 128,\n    ) -&gt; None:\n        \"\"\"\n        Set the impedance gains of the joint in real units: Nm/rad and Nm/rad/s.\n        This sets the impedance at the output and automatically scales based on gear raitos.\n\n        Conversion:\n            K_motor = K_joint / (gear_ratio ** 2)\n            B_motor = B_joint / (gear_ratio ** 2)\n\n        Args:\n            kp (float): Proportional gain. Defaults to 40.\n            ki (float): Integral gain. Defaults to 400.\n            kd (float): Derivative gain. Defaults to 0.\n            k (float): Spring constant. Defaults to 100 Nm/rad.\n            b (float): Damping constant. Defaults to 3.0 Nm/rad/s.\n            ff (float): Feedforward gain. Defaults to 128.\n        \"\"\"\n        self.set_motor_impedance(\n            kp=kp,\n            ki=ki,\n            kd=kd,\n            k=k / (self.gear_ratio**2),\n            b=b / (self.gear_ratio**2),\n            ff=ff,\n        )\n\n    def set_impedance_gains(\n        self,\n        kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n        ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n        kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n        k: float = DEFAULT_IMPEDANCE_GAINS.k,\n        b: float = DEFAULT_IMPEDANCE_GAINS.b,\n        ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the impedance gains in arbitrary actpack units.\n        See Dephy's webpage for conversions or use other library methods that handle conversion for you.\n\n        Args:\n            kp (float): The proportional gain\n            ki (float): The integral gain\n            kd (float): The derivative gain\n            k (float): The spring constant\n            b (float): The damping constant\n            ff (float): The feedforward gain\n        \"\"\"\n        self.set_gains(\n            kp=int(kp),\n            ki=int(ki),\n            kd=int(kd),\n            k=int(k),\n            b=int(b),\n            ff=int(ff),\n        )\n\n    def set_motor_impedance(\n        self,\n        kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n        ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n        kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n        k: float = 0.08922,\n        b: float = 0.0038070,\n        ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Set the impedance gains of the motor in real units: Nm/rad and Nm/rad/s.\n\n        Args:\n            kp (float): Proportional gain. Defaults to 40.\n            ki (float): Integral gain. Defaults to 400.\n            kd (float): Derivative gain. Defaults to 0.\n            k (float): Spring constant. Defaults to 0.08922 Nm/rad.\n            b (float): Damping constant. Defaults to 0.0038070 Nm/rad/s.\n            ff (float): Feedforward gain. Defaults to 128.\n        \"\"\"\n        self.set_impedance_gains(\n            kp=kp,\n            ki=ki,\n            kd=kd,\n            k=int(k * self.MOTOR_CONSTANTS.NM_PER_RAD_TO_K),\n            b=int(b * self.MOTOR_CONSTANTS.NM_S_PER_RAD_TO_B),\n            ff=ff,\n        )\n\n    def set_encoder_map(self, encoder_map: np.polynomial.polynomial.Polynomial) -&gt; None:\n        \"\"\"Sets the joint encoder map\"\"\"\n        self._encoder_map: np.polynomial.polynomial.Polynomial = encoder_map\n\n    @property\n    def encoder_map(self) -&gt; Optional[np.polynomial.polynomial.Polynomial]:\n        \"\"\"Polynomial coefficients defining the joint encoder map from counts to radians.\"\"\"\n        if getattr(self, \"_encoder_map\", None) is not None:\n            return self._encoder_map\n        else:\n            LOGGER.warning(msg=\"Encoder map is not set. Please call the make_encoder_map method to create one.\")\n            return None\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        \"\"\"Q-axis motor voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data[\"mot_volt\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_current(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[\"mot_cur\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_torque(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[\"mot_cur\"] * self.MOTOR_CONSTANTS.NM_PER_MILLIAMP)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_position(self) -&gt; float:\n        if self._data is not None:\n            return (\n                float(self._data[\"mot_ang\"] * self.MOTOR_CONSTANTS.RAD_PER_COUNT)\n                - self.motor_zero_position\n                - self.motor_position_offset\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_encoder_counts(self) -&gt; int:\n        \"\"\"Raw reading from motor encoder in counts.\"\"\"\n        if self._data is not None:\n            return int(self._data[\"mot_ang\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def joint_encoder_counts(self) -&gt; int:\n        \"\"\"Raw reading from joint encoder in counts.\"\"\"\n        if self._data is not None:\n            return int(self._data[\"ank_ang\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        if self._data is not None:\n            return int(self._data[\"mot_vel\"]) * RAD_PER_DEG\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_acceleration(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[\"mot_acc\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_voltage(self) -&gt; float:\n        \"\"\"Battery voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data[\"batt_volt\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_current(self) -&gt; float:\n        \"\"\"Battery current in mA.\"\"\"\n        if self._data is not None:\n            return float(self._data[\"batt_curr\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_position(self) -&gt; float:\n        if self._data is not None:\n            return (\n                float(self._data[\"ank_ang\"] * self.MOTOR_CONSTANTS.RAD_PER_COUNT)\n                - self.joint_zero_position\n                - self.joint_position_offset\n            ) * self.joint_direction\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_velocity(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[\"ank_vel\"] * RAD_PER_DEG) * self.joint_direction\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the joint output in Nm.\n        This is calculated using motor current, k_t, and the gear ratio.\n        \"\"\"\n        return self.motor_torque * self.gear_ratio\n\n    @property\n    def case_temperature(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[\"temperature\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        ESTIMATED temperature of the windings in celsius.\n        This is calculated based on the thermal model using motor current.\n        \"\"\"\n        if self._data is not None:\n            return float(self._thermal_model.T_w)\n        else:\n            return 0.0\n\n    @property\n    def genvars(self) -&gt; np.ndarray:\n        \"\"\"Dephy's 'genvars' object.\"\"\"\n        if self._data is not None:\n            return np.array(\n                object=[\n                    self._data[\"genvar_0\"],\n                    self._data[\"genvar_1\"],\n                    self._data[\"genvar_2\"],\n                    self._data[\"genvar_3\"],\n                    self._data[\"genvar_4\"],\n                    self._data[\"genvar_5\"],\n                ]\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning zeros\"\n            )\n            return np.zeros(shape=6)\n\n    @property\n    def accelx(self) -&gt; float:\n        \"\"\"\n        Acceleration in x direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"accelx\"] * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accely(self) -&gt; float:\n        \"\"\"\n        Acceleration in y direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"accely\"] * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accelz(self) -&gt; float:\n        \"\"\"\n        Acceleration in z direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"accelz\"] * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyrox(self) -&gt; float:\n        \"\"\"\n        Angular velocity in x direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"gyrox\"] * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyroy(self) -&gt; float:\n        \"\"\"\n        Angular velocity in y direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"gyroy\"] * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyroz(self) -&gt; float:\n        \"\"\"\n        Angular velocity in z direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"gyroz\"] * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def thermal_scaling_factor(self) -&gt; float:\n        \"\"\"\n        Scale factor to use in torque control, in [0,1].\n        If you scale the torque command by this factor, the motor temperature will never\n        exceed max allowable temperature. For a proof, see paper referenced in thermal model.\n        \"\"\"\n        return self._thermal_scale\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.accelx","title":"<code>accelx: float</code>  <code>property</code>","text":"<p>Acceleration in x direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.accely","title":"<code>accely: float</code>  <code>property</code>","text":"<p>Acceleration in y direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.accelz","title":"<code>accelz: float</code>  <code>property</code>","text":"<p>Acceleration in z direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.battery_current","title":"<code>battery_current: float</code>  <code>property</code>","text":"<p>Battery current in mA.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.battery_voltage","title":"<code>battery_voltage: float</code>  <code>property</code>","text":"<p>Battery voltage in mV.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.encoder_map","title":"<code>encoder_map: Optional[np.polynomial.polynomial.Polynomial]</code>  <code>property</code>","text":"<p>Polynomial coefficients defining the joint encoder map from counts to radians.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.genvars","title":"<code>genvars: np.ndarray</code>  <code>property</code>","text":"<p>Dephy's 'genvars' object.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.gyrox","title":"<code>gyrox: float</code>  <code>property</code>","text":"<p>Angular velocity in x direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.gyroy","title":"<code>gyroy: float</code>  <code>property</code>","text":"<p>Angular velocity in y direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.gyroz","title":"<code>gyroz: float</code>  <code>property</code>","text":"<p>Angular velocity in z direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.joint_encoder_counts","title":"<code>joint_encoder_counts: int</code>  <code>property</code>","text":"<p>Raw reading from joint encoder in counts.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.joint_torque","title":"<code>joint_torque: float</code>  <code>property</code>","text":"<p>Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.motor_encoder_counts","title":"<code>motor_encoder_counts: int</code>  <code>property</code>","text":"<p>Raw reading from motor encoder in counts.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.motor_voltage","title":"<code>motor_voltage: float</code>  <code>property</code>","text":"<p>Q-axis motor voltage in mV.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.thermal_scaling_factor","title":"<code>thermal_scaling_factor: float</code>  <code>property</code>","text":"<p>Scale factor to use in torque control, in [0,1]. If you scale the torque command by this factor, the motor temperature will never exceed max allowable temperature. For a proof, see paper referenced in thermal model.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.winding_temperature","title":"<code>winding_temperature: float</code>  <code>property</code>","text":"<p>ESTIMATED temperature of the windings in celsius. This is calculated based on the thermal model using motor current.</p>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.home","title":"<code>home(homing_voltage=2000, homing_frequency=None, homing_direction=-1, joint_direction=-1, joint_position_offset=0.0, motor_position_offset=0.0, current_threshold=5000, velocity_threshold=0.001)</code>","text":"<p>This method homes the actuator and the corresponding joint by moving it to the zero position. The zero position is defined as the position where the joint is fully extended. This method will also load the encoder map if it exists. The encoder map is a polynomial that maps the encoder counts to joint position in radians. This is useful for more accurate joint position estimation. Args:     homing_voltage (int): Voltage in mV to use for homing. Default is 2000 mV.     homing_frequency (int): Frequency in Hz to use for homing. Default is the actuator's frequency.     homing_direction (int): Direction to move the actuator during homing. Default is -1.     joint_direction (int): Direction to move the joint during homing. Default is -1.     joint_position_offset (float): Offset in radians to add to the joint position. Default is 0.0.     motor_position_offset (float): Offset in radians to add to the motor position. Default is 0.0.     current_threshold (int): Current threshold in mA to stop homing the joint or actuator.         This is used to detect if the actuator or joint has hit a hard stop. Default is 5000 mA.     velocity_threshold (float): Velocity threshold in rad/s to stop homing the joint or actuator.         This is also used to detect if the actuator or joint has hit a hard stop. Default is 0.001 rad/s.</p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def home(\n    self,\n    homing_voltage: int = 2000,\n    homing_frequency: Optional[int] = None,\n    homing_direction: int = -1,\n    joint_direction: int = -1,\n    joint_position_offset: float = 0.0,\n    motor_position_offset: float = 0.0,\n    current_threshold: int = 5000,\n    velocity_threshold: float = 0.001,\n) -&gt; None:\n    \"\"\"\n\n    This method homes the actuator and the corresponding joint by moving it to the zero position.\n    The zero position is defined as the position where the joint is fully extended. This method will\n    also load the encoder map if it exists. The encoder map is a polynomial that maps the encoder counts\n    to joint position in radians. This is useful for more accurate joint position estimation.\n    Args:\n        homing_voltage (int): Voltage in mV to use for homing. Default is 2000 mV.\n        homing_frequency (int): Frequency in Hz to use for homing. Default is the actuator's frequency.\n        homing_direction (int): Direction to move the actuator during homing. Default is -1.\n        joint_direction (int): Direction to move the joint during homing. Default is -1.\n        joint_position_offset (float): Offset in radians to add to the joint position. Default is 0.0.\n        motor_position_offset (float): Offset in radians to add to the motor position. Default is 0.0.\n        current_threshold (int): Current threshold in mA to stop homing the joint or actuator.\n            This is used to detect if the actuator or joint has hit a hard stop. Default is 5000 mA.\n        velocity_threshold (float): Velocity threshold in rad/s to stop homing the joint or actuator.\n            This is also used to detect if the actuator or joint has hit a hard stop. Default is 0.001 rad/s.\n\n    \"\"\"\n    is_homing = True\n    homing_frequency = homing_frequency if homing_frequency is not None else self.frequency\n\n    self.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n\n    self.set_motor_voltage(value=homing_direction * homing_voltage)  # mV, negative for counterclockwise\n\n    _motor_encoder_array = []\n    _joint_encoder_array = []\n\n    time.sleep(0.1)\n\n    try:\n        while is_homing:\n            self.update()\n            time.sleep(1 / homing_frequency)\n\n            _motor_encoder_array.append(self.motor_position)\n            _joint_encoder_array.append(self.joint_position)\n\n            if abs(self.output_velocity) &lt;= velocity_threshold or abs(self.motor_current) &gt;= current_threshold:\n                self.set_motor_voltage(value=0)\n                is_homing = False\n\n    except KeyboardInterrupt:\n        self.set_motor_voltage(value=0)\n        LOGGER.info(msg=f\"[{self.__repr__()}] Homing interrupted.\")\n        return\n    except Exception as e:\n        self.set_motor_voltage(value=0)\n        LOGGER.error(msg=f\"[{self.__repr__()}] Homing failed: {e}\")\n        return\n\n    self.set_motor_zero_position(value=self.motor_position)\n    self.set_joint_zero_position(value=self.joint_position)\n\n    time.sleep(0.1)\n    self.set_joint_direction(joint_direction)\n    self.set_motor_position_offset(motor_position_offset)\n    self.set_joint_position_offset(joint_position_offset)\n\n    self._is_homed = True\n    LOGGER.info(f\"[{self.__repr__()}] Homing complete.\")\n\n    if os.path.isfile(path=f\"./{self.tag}_encoder_map.npy\"):\n        coefficients = np.load(file=f\"./{self.tag}_encoder_map.npy\")\n        self.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=coefficients))\n    else:\n        LOGGER.debug(\n            msg=f\"[{self.__repr__()}] No encoder map found. Please call the make_encoder_map method \\\n                to create one. The encoder map is used to estimate joint position more accurately.\"\n        )\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.make_encoder_map","title":"<code>make_encoder_map(overwrite=False)</code>","text":"<p>This method makes a lookup table to calculate the position measured by the joint encoder. This is necessary because the magnetic output encoders are nonlinear. By making the map while the joint is unloaded, joint position calculated by motor position * gear ratio should be the same as the true joint position.</p> <p>Output from this function is a file containing a_i values parameterizing the map</p> <p>Eqn: position = sum from i=0^5 (a_i*counts^i)</p> Kevin Best <p>U-M Locolab | Neurobionics Lab Gitub: tkevinbest, https://github.com/tkevinbest</p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def make_encoder_map(self, overwrite: bool = False) -&gt; None:\n    \"\"\"\n    This method makes a lookup table to calculate the position measured by the joint encoder.\n    This is necessary because the magnetic output encoders are nonlinear.\n    By making the map while the joint is unloaded, joint position calculated by motor position * gear ratio\n    should be the same as the true joint position.\n\n    Output from this function is a file containing a_i values parameterizing the map\n\n    Eqn: position = sum from i=0^5 (a_i*counts^i)\n\n    Author: Kevin Best\n            U-M Locolab | Neurobionics Lab\n            Gitub: tkevinbest, https://github.com/tkevinbest\n    \"\"\"\n\n    if not self.is_homed:\n        LOGGER.warning(msg=f\"[{self.__repr__()}] Please home the {self.tag} joint before making the encoder map.\")\n        return None\n\n    if os.path.exists(f\"./{self.tag}_encoder_map.npy\") and not overwrite:\n        LOGGER.info(msg=f\"[{self.__repr__()}] Encoder map exists. Skipping encoder map creation.\")\n        return None\n\n    self.set_control_mode(mode=CONTROL_MODES.CURRENT)\n    self.set_current_gains()\n    time.sleep(0.1)\n    self.set_current_gains()\n\n    self.set_joint_torque(value=0.0)\n    time.sleep(0.1)\n    self.set_joint_torque(value=0.0)\n\n    _joint_encoder_array = []\n    _output_position_array = []\n\n    LOGGER.info(\n        msg=f\"[{self.__repr__()}] Please manually move the {self.tag} joint numerous times through \\\n            its full range of motion for 10 seconds. \\n{input('Press any key when you are ready to start.')}\"\n    )\n\n    _start_time: float = time.time()\n\n    try:\n        while time.time() - _start_time &lt; 10:\n            LOGGER.info(\n                msg=f\"[{self.__repr__()}] Mapping the {self.tag} \\\n                    joint encoder: {10 - time.time() + _start_time} seconds left.\"\n            )\n            self.update()\n            _joint_encoder_array.append(self.joint_encoder_counts)\n            _output_position_array.append(self.output_position)\n            time.sleep(1 / self.frequency)\n\n    except KeyboardInterrupt:\n        LOGGER.warning(msg=\"Encoder map interrupted.\")\n        return None\n\n    LOGGER.info(msg=f\"[{self.__repr__()}] You may now stop moving the {self.tag} joint.\")\n\n    _power = np.arange(4.0)\n    _a_mat = np.array(_joint_encoder_array).reshape(-1, 1) ** _power\n    _beta = np.linalg.lstsq(_a_mat, _output_position_array, rcond=None)\n    _coeffs = _beta[0]\n\n    self.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=_coeffs))\n\n    np.save(file=f\"./{self.tag}_encoder_map.npy\", arr=_coeffs)\n    LOGGER.info(msg=f\"[{self.__repr__()}] Encoder map saved to './{self.tag}_encoder_map.npy'.\")\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_current_gains","title":"<code>set_current_gains(kp=DEFAULT_CURRENT_GAINS.kp, ki=DEFAULT_CURRENT_GAINS.ki, kd=DEFAULT_CURRENT_GAINS.kd, ff=DEFAULT_CURRENT_GAINS.ff)</code>","text":"<p>Sets the current gains in arbitrary Dephy units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_current_gains(\n    self,\n    kp: float = DEFAULT_CURRENT_GAINS.kp,\n    ki: float = DEFAULT_CURRENT_GAINS.ki,\n    kd: float = DEFAULT_CURRENT_GAINS.kd,\n    ff: float = DEFAULT_CURRENT_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the current gains in arbitrary Dephy units.\n\n    Args:\n        kp (float): The proportional gain\n        ki (float): The integral gain\n        kd (float): The derivative gain\n        ff (float): The feedforward gain\n    \"\"\"\n    self.set_gains(\n        kp=int(kp),\n        ki=int(ki),\n        kd=int(kd),\n        k=0,\n        b=0,\n        ff=int(ff),\n    )\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_encoder_map","title":"<code>set_encoder_map(encoder_map)</code>","text":"<p>Sets the joint encoder map</p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_encoder_map(self, encoder_map: np.polynomial.polynomial.Polynomial) -&gt; None:\n    \"\"\"Sets the joint encoder map\"\"\"\n    self._encoder_map: np.polynomial.polynomial.Polynomial = encoder_map\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_impedance_gains","title":"<code>set_impedance_gains(kp=DEFAULT_IMPEDANCE_GAINS.kp, ki=DEFAULT_IMPEDANCE_GAINS.ki, kd=DEFAULT_IMPEDANCE_GAINS.kd, k=DEFAULT_IMPEDANCE_GAINS.k, b=DEFAULT_IMPEDANCE_GAINS.b, ff=DEFAULT_IMPEDANCE_GAINS.ff)</code>","text":"<p>Sets the impedance gains in arbitrary actpack units. See Dephy's webpage for conversions or use other library methods that handle conversion for you.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>k</code> <code>float</code> <p>The spring constant</p> <code>k</code> <code>b</code> <code>float</code> <p>The damping constant</p> <code>b</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_impedance_gains(\n    self,\n    kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n    ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n    kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n    k: float = DEFAULT_IMPEDANCE_GAINS.k,\n    b: float = DEFAULT_IMPEDANCE_GAINS.b,\n    ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the impedance gains in arbitrary actpack units.\n    See Dephy's webpage for conversions or use other library methods that handle conversion for you.\n\n    Args:\n        kp (float): The proportional gain\n        ki (float): The integral gain\n        kd (float): The derivative gain\n        k (float): The spring constant\n        b (float): The damping constant\n        ff (float): The feedforward gain\n    \"\"\"\n    self.set_gains(\n        kp=int(kp),\n        ki=int(ki),\n        kd=int(kd),\n        k=int(k),\n        b=int(b),\n        ff=int(ff),\n    )\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_joint_torque","title":"<code>set_joint_torque(value)</code>","text":"<p>Set the joint torque of the joint. This is the torque that is applied to the joint, not the motor.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>torque in N_m</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_joint_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the joint torque of the joint.\n    This is the torque that is applied to the joint, not the motor.\n\n    Args:\n        value (float): torque in N_m\n    \"\"\"\n    self.set_motor_torque(value=value / self.gear_ratio)\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_motor_current","title":"<code>set_motor_current(value)</code>","text":"<p>Sets the motor current in mA.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The current to set in mA.</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_current(\n    self,\n    value: float,\n) -&gt; None:\n    \"\"\"\n    Sets the motor current in mA.\n\n    Args:\n        value (float): The current to set in mA.\n    \"\"\"\n    self.command_motor_current(value=int(value))\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_motor_impedance","title":"<code>set_motor_impedance(kp=DEFAULT_IMPEDANCE_GAINS.kp, ki=DEFAULT_IMPEDANCE_GAINS.ki, kd=DEFAULT_IMPEDANCE_GAINS.kd, k=0.08922, b=0.003807, ff=DEFAULT_IMPEDANCE_GAINS.ff)</code>","text":"<p>Set the impedance gains of the motor in real units: Nm/rad and Nm/rad/s.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>Proportional gain. Defaults to 40.</p> <code>kp</code> <code>ki</code> <code>float</code> <p>Integral gain. Defaults to 400.</p> <code>ki</code> <code>kd</code> <code>float</code> <p>Derivative gain. Defaults to 0.</p> <code>kd</code> <code>k</code> <code>float</code> <p>Spring constant. Defaults to 0.08922 Nm/rad.</p> <code>0.08922</code> <code>b</code> <code>float</code> <p>Damping constant. Defaults to 0.0038070 Nm/rad/s.</p> <code>0.003807</code> <code>ff</code> <code>float</code> <p>Feedforward gain. Defaults to 128.</p> <code>ff</code> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_impedance(\n    self,\n    kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n    ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n    kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n    k: float = 0.08922,\n    b: float = 0.0038070,\n    ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Set the impedance gains of the motor in real units: Nm/rad and Nm/rad/s.\n\n    Args:\n        kp (float): Proportional gain. Defaults to 40.\n        ki (float): Integral gain. Defaults to 400.\n        kd (float): Derivative gain. Defaults to 0.\n        k (float): Spring constant. Defaults to 0.08922 Nm/rad.\n        b (float): Damping constant. Defaults to 0.0038070 Nm/rad/s.\n        ff (float): Feedforward gain. Defaults to 128.\n    \"\"\"\n    self.set_impedance_gains(\n        kp=kp,\n        ki=ki,\n        kd=kd,\n        k=int(k * self.MOTOR_CONSTANTS.NM_PER_RAD_TO_K),\n        b=int(b * self.MOTOR_CONSTANTS.NM_S_PER_RAD_TO_B),\n        ff=ff,\n    )\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Sets the motor position in radians. If in impedance mode, this sets the equilibrium angle in radians.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor position in radians.\n    If in impedance mode, this sets the equilibrium angle in radians.\n\n    Args:\n        value (float): The position to set\n    \"\"\"\n    self.command_motor_position(\n        value=int(\n            (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n        ),\n    )\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_motor_torque","title":"<code>set_motor_torque(value)</code>","text":"<p>Sets the motor torque in Nm. This is the torque that is applied to the motor rotor, not the joint or output. Args:     value (float): The torque to set in Nm.</p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor torque in Nm. This is the torque that is applied to the motor rotor, not the joint or output.\n    Args:\n        value (float): The torque to set in Nm.\n    \"\"\"\n    self.set_motor_current(\n        value / self.MOTOR_CONSTANTS.NM_PER_MILLIAMP,\n    )\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>","text":"<p>Sets the motor voltage in mV.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage to set in mV.</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor voltage in mV.\n\n    Args:\n        value (float): The voltage to set in mV.\n    \"\"\"\n    self.command_motor_voltage(value=int(value))\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_output_impedance","title":"<code>set_output_impedance(kp=DEFAULT_IMPEDANCE_GAINS.kp, ki=DEFAULT_IMPEDANCE_GAINS.ki, kd=DEFAULT_IMPEDANCE_GAINS.kd, k=100.0, b=3.0, ff=128)</code>","text":"<p>Set the impedance gains of the joint in real units: Nm/rad and Nm/rad/s. This sets the impedance at the output and automatically scales based on gear raitos.</p> Conversion <p>K_motor = K_joint / (gear_ratio ** 2) B_motor = B_joint / (gear_ratio ** 2)</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>Proportional gain. Defaults to 40.</p> <code>kp</code> <code>ki</code> <code>float</code> <p>Integral gain. Defaults to 400.</p> <code>ki</code> <code>kd</code> <code>float</code> <p>Derivative gain. Defaults to 0.</p> <code>kd</code> <code>k</code> <code>float</code> <p>Spring constant. Defaults to 100 Nm/rad.</p> <code>100.0</code> <code>b</code> <code>float</code> <p>Damping constant. Defaults to 3.0 Nm/rad/s.</p> <code>3.0</code> <code>ff</code> <code>float</code> <p>Feedforward gain. Defaults to 128.</p> <code>128</code> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_output_impedance(\n    self,\n    kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n    ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n    kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n    k: float = 100.0,\n    b: float = 3.0,\n    ff: float = 128,\n) -&gt; None:\n    \"\"\"\n    Set the impedance gains of the joint in real units: Nm/rad and Nm/rad/s.\n    This sets the impedance at the output and automatically scales based on gear raitos.\n\n    Conversion:\n        K_motor = K_joint / (gear_ratio ** 2)\n        B_motor = B_joint / (gear_ratio ** 2)\n\n    Args:\n        kp (float): Proportional gain. Defaults to 40.\n        ki (float): Integral gain. Defaults to 400.\n        kd (float): Derivative gain. Defaults to 0.\n        k (float): Spring constant. Defaults to 100 Nm/rad.\n        b (float): Damping constant. Defaults to 3.0 Nm/rad/s.\n        ff (float): Feedforward gain. Defaults to 128.\n    \"\"\"\n    self.set_motor_impedance(\n        kp=kp,\n        ki=ki,\n        kd=kd,\n        k=k / (self.gear_ratio**2),\n        b=b / (self.gear_ratio**2),\n        ff=ff,\n    )\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_output_torque","title":"<code>set_output_torque(value)</code>","text":"<p>Set the output torque of the joint. This is the torque that is applied to the joint, not the motor.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>torque in N_m</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>@deprecated_with_routing(alternative_func=set_joint_torque)\ndef set_output_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the output torque of the joint.\n    This is the torque that is applied to the joint, not the motor.\n\n    Args:\n        value (float): torque in N_m\n    \"\"\"\n    self.set_motor_torque(value=value / self.gear_ratio)\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyActuator.set_position_gains","title":"<code>set_position_gains(kp=DEFAULT_POSITION_GAINS.kp, ki=DEFAULT_POSITION_GAINS.ki, kd=DEFAULT_POSITION_GAINS.kd, ff=DEFAULT_POSITION_GAINS.ff)</code>","text":"<p>Sets the position gains in arbitrary Dephy units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_position_gains(\n    self,\n    kp: float = DEFAULT_POSITION_GAINS.kp,\n    ki: float = DEFAULT_POSITION_GAINS.ki,\n    kd: float = DEFAULT_POSITION_GAINS.kd,\n    ff: float = DEFAULT_POSITION_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the position gains in arbitrary Dephy units.\n\n    Args:\n        kp (float): The proportional gain\n        ki (float): The integral gain\n        kd (float): The derivative gain\n        ff (float): The feedforward gain\n    \"\"\"\n    self.set_gains(\n        kp=int(kp),\n        ki=int(ki),\n        kd=int(kd),\n        k=0,\n        b=0,\n        ff=int(ff),\n    )\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator","title":"<code>DephyLegacyActuator</code>","text":"<p>               Bases: <code>DephyActuator</code></p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>class DephyLegacyActuator(DephyActuator):\n    def __init__(\n        self,\n        tag: str = \"DephyActuator\",\n        port: str = \"/dev/ttyACM0\",\n        gear_ratio: float = 1.0,\n        baud_rate: int = 230400,\n        frequency: int = 500,\n        debug_level: int = 4,\n        dephy_log: bool = False,\n        offline: bool = False,\n    ) -&gt; None:\n        ActuatorBase.__init__(\n            self,\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=DEPHY_ACTUATOR_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n        )\n\n        self._debug_level: int = debug_level if dephy_log else 6\n        self._dephy_log: bool = dephy_log\n\n        if self.is_offline:\n            self.port = port\n            self._is_streaming: bool = False\n            self._is_open: bool = False\n        else:\n            # def set_is_streaming(self, value):\n            #     self._is_streaming = value\n\n            # def set_is_open(self, value):\n            #     self._is_open = value\n\n            # type(self).is_streaming = property(fset=set_is_streaming)\n            # type(self).is_open = property(fset=set_is_open)\n\n            Device.__init__(self, port=port, baud_rate=baud_rate)\n\n        self._thermal_model: ThermalModel = ThermalModel(\n            temp_limit_windings=self.max_winding_temperature,\n            soft_border_C_windings=10,\n            temp_limit_case=self.max_case_temperature,\n            soft_border_C_case=10,\n        )\n        self._thermal_scale: float = 1.0\n\n        self._mode = CONTROL_MODES.IDLE\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.tag}[DephyActuator]\"\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return DEPHY_LEGACY_CONTROL_MODE_CONFIGS\n\n    @check_actuator_connection\n    def start(self) -&gt; None:\n        try:\n            self.open(\n                freq=self._frequency,\n                log_level=self._debug_level,\n                log_enabled=self._dephy_log,\n            )\n        except OSError:\n            print(\"\\n\")\n            LOGGER.error(\n                msg=f\"[{self.__repr__()}] Need admin previleges to open the port '{self.port}'. \\n\\n \\\n                    Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n            )\n            os._exit(status=1)\n\n        self._data = self.read()\n\n        # TODO: Verify if we need this sleep here\n        time.sleep(0.1)\n        self.set_control_mode(CONTROL_MODES.VOLTAGE)\n\n    @check_actuator_stream\n    @check_actuator_open\n    def stop(self) -&gt; None:\n        self.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n        self.set_motor_voltage(value=0)\n\n        self.set_control_mode(mode=CONTROL_MODES.IDLE)\n        time.sleep(0.1)\n        self.close()\n\n    def update(self) -&gt; None:\n        self._data = self.read()\n\n        self._thermal_model.T_c = self.case_temperature\n        self._thermal_scale = self._thermal_model.update_and_get_scale(\n            dt=1 / self.frequency,\n            motor_current=self.motor_current,\n        )\n        if self.case_temperature &gt;= self.max_case_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Case thermal limit {self.max_case_temperature} reached. \\\n                    Stopping motor.\"\n            )\n            raise ThermalLimitException()\n\n        if self.winding_temperature &gt;= self.max_winding_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Winding thermal limit {self.max_winding_temperature} reached. \\\n                    Stopping motor.\"\n            )\n            raise ThermalLimitException()\n        # Check for thermal fault, bit 2 of the execute status byte\n\n        if self._data.status_ex &amp; 0b00000010 == 0b00000010:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Thermal Fault: Winding temperature: {self.winding_temperature}; \\\n                    Case temperature: {self.case_temperature}.\"\n            )\n            raise ThermalLimitException(\"Internal thermal limit tripped.\")\n\n    def set_motor_current(\n        self,\n        value: float,\n    ) -&gt; None:\n        \"\"\"\n        Sets the motor current in mA.\n\n        Args:\n            value (float): The current to set in mA.\n        \"\"\"\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_current)\n    def set_current(self, value: float) -&gt; None:\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor voltage in mV.\n\n        Args:\n            value (float): The voltage to set in mV.\n        \"\"\"\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_voltage)\n    def set_voltage(self, value: float) -&gt; None:\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor position in radians.\n        If in impedance mode, this sets the equilibrium angle in radians.\n\n        Args:\n            value (float): The position to set\n        \"\"\"\n        self.send_motor_command(\n            ctrl_mode=c_int(self.mode.value),\n            value=int(\n                (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n            ),\n        )\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        \"\"\"Q-axis motor voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data.mot_volt)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_current(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data.mot_cur)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the motor output in Nm.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.mot_cur * self.MOTOR_CONSTANTS.NM_PER_MILLIAMP)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_position(self) -&gt; float:\n        \"\"\"\n        Motor position in radians.\n        \"\"\"\n        if self._data is not None:\n            return (\n                float(self._data.mot_ang * self.MOTOR_CONSTANTS.RAD_PER_COUNT)\n                - self.motor_zero_position\n                - self.motor_position_offset\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_encoder_counts(self) -&gt; int:\n        \"\"\"Raw reading from motor encoder in counts.\"\"\"\n        if self._data is not None:\n            return int(self._data.mot_ang)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def joint_encoder_counts(self) -&gt; int:\n        \"\"\"Raw reading from joint encoder in counts.\"\"\"\n        if self._data is not None:\n            return int(self._data.ank_ang)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        \"\"\"\n        Motor velocity in rad/s.\n        \"\"\"\n        if self._data is not None:\n            return int(self._data.mot_vel) * RAD_PER_DEG\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_acceleration(self) -&gt; float:\n        \"\"\"\n        Motor acceleration in rad/s^2.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.mot_acc)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_voltage(self) -&gt; float:\n        \"\"\"Battery voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data.batt_volt)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_current(self) -&gt; float:\n        \"\"\"Battery current in mA.\"\"\"\n        if self._data is not None:\n            return float(self._data.batt_curr)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_position(self) -&gt; float:\n        \"\"\"\n        Joint position in radians.\n        \"\"\"\n        if self._data is not None:\n            return (\n                float(self._data.ank_ang * self.MOTOR_CONSTANTS.RAD_PER_COUNT)\n                - self.joint_zero_position\n                - self.joint_position_offset\n            ) * self.joint_direction\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_velocity(self) -&gt; float:\n        \"\"\"\n        Joint velocity in rad/s.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.ank_vel * RAD_PER_DEG) * self.joint_direction\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the joint output in Nm.\n        This is calculated using motor current, k_t, and the gear ratio.\n        \"\"\"\n        return self.motor_torque * self.gear_ratio\n\n    @property\n    def case_temperature(self) -&gt; float:\n        \"\"\"\n        Case temperature of the actuator in celsius.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.temperature)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        ESTIMATED temperature of the windings in celsius.\n        This is calculated based on the thermal model using motor current.\n        \"\"\"\n        if self._data is not None:\n            return float(self._thermal_model.T_w)\n        else:\n            return 0.0\n\n    @property\n    def genvars(self) -&gt; np.ndarray:\n        \"\"\"Dephy's 'genvars' object.\"\"\"\n        if self._data is not None:\n            return np.array(\n                object=[\n                    self._data.genvar_0,\n                    self._data.genvar_1,\n                    self._data.genvar_2,\n                    self._data.genvar_3,\n                    self._data.genvar_4,\n                    self._data.genvar_5,\n                ]\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning zeros\"\n            )\n            return np.zeros(shape=6)\n\n    @property\n    def accelx(self) -&gt; float:\n        \"\"\"\n        Acceleration in x direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.accelx * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accely(self) -&gt; float:\n        \"\"\"\n        Acceleration in y direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.accely * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accelz(self) -&gt; float:\n        \"\"\"\n        Acceleration in z direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.accelz * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyrox(self) -&gt; float:\n        \"\"\"\n        Angular velocity in x direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.gyrox * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyroy(self) -&gt; float:\n        \"\"\"\n        Angular velocity in y direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.gyroy * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        return self._is_streaming\n\n    @is_streaming.setter\n    def is_streaming(self, value: bool) -&gt; None:\n        self._is_streaming = value\n\n    @property\n    def is_open(self) -&gt; bool:\n        return self._is_open\n\n    @is_open.setter\n    def is_open(self, value: bool) -&gt; None:\n        self._is_open = value\n\n    @property\n    def gyroz(self) -&gt; float:\n        \"\"\"\n        Angular velocity in z direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.gyroz * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.accelx","title":"<code>accelx: float</code>  <code>property</code>","text":"<p>Acceleration in x direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.accely","title":"<code>accely: float</code>  <code>property</code>","text":"<p>Acceleration in y direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.accelz","title":"<code>accelz: float</code>  <code>property</code>","text":"<p>Acceleration in z direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.battery_current","title":"<code>battery_current: float</code>  <code>property</code>","text":"<p>Battery current in mA.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.battery_voltage","title":"<code>battery_voltage: float</code>  <code>property</code>","text":"<p>Battery voltage in mV.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.case_temperature","title":"<code>case_temperature: float</code>  <code>property</code>","text":"<p>Case temperature of the actuator in celsius.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.genvars","title":"<code>genvars: np.ndarray</code>  <code>property</code>","text":"<p>Dephy's 'genvars' object.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.gyrox","title":"<code>gyrox: float</code>  <code>property</code>","text":"<p>Angular velocity in x direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.gyroy","title":"<code>gyroy: float</code>  <code>property</code>","text":"<p>Angular velocity in y direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.gyroz","title":"<code>gyroz: float</code>  <code>property</code>","text":"<p>Angular velocity in z direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.joint_encoder_counts","title":"<code>joint_encoder_counts: int</code>  <code>property</code>","text":"<p>Raw reading from joint encoder in counts.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.joint_position","title":"<code>joint_position: float</code>  <code>property</code>","text":"<p>Joint position in radians.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.joint_torque","title":"<code>joint_torque: float</code>  <code>property</code>","text":"<p>Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.joint_velocity","title":"<code>joint_velocity: float</code>  <code>property</code>","text":"<p>Joint velocity in rad/s.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.motor_acceleration","title":"<code>motor_acceleration: float</code>  <code>property</code>","text":"<p>Motor acceleration in rad/s^2.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.motor_encoder_counts","title":"<code>motor_encoder_counts: int</code>  <code>property</code>","text":"<p>Raw reading from motor encoder in counts.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.motor_position","title":"<code>motor_position: float</code>  <code>property</code>","text":"<p>Motor position in radians.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.motor_torque","title":"<code>motor_torque: float</code>  <code>property</code>","text":"<p>Torque at the motor output in Nm.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.motor_velocity","title":"<code>motor_velocity: float</code>  <code>property</code>","text":"<p>Motor velocity in rad/s.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.motor_voltage","title":"<code>motor_voltage: float</code>  <code>property</code>","text":"<p>Q-axis motor voltage in mV.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.winding_temperature","title":"<code>winding_temperature: float</code>  <code>property</code>","text":"<p>ESTIMATED temperature of the windings in celsius. This is calculated based on the thermal model using motor current.</p>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.set_motor_current","title":"<code>set_motor_current(value)</code>","text":"<p>Sets the motor current in mA.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The current to set in mA.</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_current(\n    self,\n    value: float,\n) -&gt; None:\n    \"\"\"\n    Sets the motor current in mA.\n\n    Args:\n        value (float): The current to set in mA.\n    \"\"\"\n    self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Sets the motor position in radians. If in impedance mode, this sets the equilibrium angle in radians.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor position in radians.\n    If in impedance mode, this sets the equilibrium angle in radians.\n\n    Args:\n        value (float): The position to set\n    \"\"\"\n    self.send_motor_command(\n        ctrl_mode=c_int(self.mode.value),\n        value=int(\n            (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n        ),\n    )\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.DephyLegacyActuator.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>","text":"<p>Sets the motor voltage in mV.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage to set in mV.</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor voltage in mV.\n\n    Args:\n        value (float): The voltage to set in mV.\n    \"\"\"\n    self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ThermalModel","title":"<code>ThermalModel</code>","text":"<p>Thermal model of a motor developed by Jianping Lin and Gray C. Thomas @U-M Locomotion Lab, directed by Dr. Robert Gregg</p> Assumptions <p>1: The motor is a lumped system with two thermal nodes: the winding and the case. 2: The winding and the case are assumed to be in thermal equilibrium with the ambient. 3: The winding and the case are assumed to be in thermal equilibrium with each other.</p> Equations <p>1: C_w * dT_w/dt = (I^2)R + (T_c-T_w)/R_WC 2: C_c * dT_c/dt = (T_w-T_c)/R_WC + (T_w-T_a)/R_CA</p> where <p>C_w: Thermal capacitance of the winding C_c: Thermal capacitance of the case R_WC: Thermal resistance between the winding and the case R_CA: Thermal resistance between the case and the ambient T_w: Temperature of the winding T_c: Temperature of the case T_a: Temperature of the ambient I: Current R: Resistance</p> Implementation <p>1: The model is updated at every time step with the current and the ambient temperature. 2: The model can be used to predict the temperature of the winding and the case at any time step. 3: The model can also be used to scale the torque based on the temperature of the winding and the case.</p> <p>Parameters:</p> Name Type Description Default <code>ambient</code> <code>float</code> <p>Ambient temperature in Celsius. Defaults to 21.</p> <code>21</code> <code>params</code> <code>dict</code> <p>Dictionary of parameters. Defaults to dict().</p> <code>None</code> <code>temp_limit_windings</code> <code>float</code> <p>Maximum temperature of the windings in Celsius. Defaults to 115.</p> <code>115</code> <code>soft_border_C_windings</code> <code>float</code> <p>Soft border of the windings in Celsius. Defaults to 15.</p> <code>15</code> <code>temp_limit_case</code> <code>float</code> <p>Maximum temperature of the case in Celsius. Defaults to 80.</p> <code>80</code> <code>soft_border_C_case</code> <code>float</code> <p>Soft border of the case in Celsius. Defaults to 5.</p> <code>5</code> Source code in <code>opensourceleg/math/math.py</code> <pre><code>class ThermalModel:\n    \"\"\"\n    Thermal model of a motor developed by Jianping Lin and Gray C. Thomas\n    @U-M Locomotion Lab, directed by Dr. Robert Gregg\n\n    Assumptions:\n        1: The motor is a lumped system with two thermal nodes: the winding and the case.\n        2: The winding and the case are assumed to be in thermal equilibrium with the ambient.\n        3: The winding and the case are assumed to be in thermal equilibrium with each other.\n\n    Equations:\n        1: C_w * dT_w/dt = (I^2)R + (T_c-T_w)/R_WC\n        2: C_c * dT_c/dt = (T_w-T_c)/R_WC + (T_w-T_a)/R_CA\n\n    where:\n        C_w: Thermal capacitance of the winding\n        C_c: Thermal capacitance of the case\n        R_WC: Thermal resistance between the winding and the case\n        R_CA: Thermal resistance between the case and the ambient\n        T_w: Temperature of the winding\n        T_c: Temperature of the case\n        T_a: Temperature of the ambient\n        I: Current\n        R: Resistance\n\n    Implementation:\n        1: The model is updated at every time step with the current and the ambient temperature.\n        2: The model can be used to predict the temperature of the winding and the case at any time step.\n        3: The model can also be used to scale the torque based on the temperature of the winding and the case.\n\n    Args:\n        ambient (float): Ambient temperature in Celsius. Defaults to 21.\n        params (dict): Dictionary of parameters. Defaults to dict().\n        temp_limit_windings (float): Maximum temperature of the windings in Celsius. Defaults to 115.\n        soft_border_C_windings (float): Soft border of the windings in Celsius. Defaults to 15.\n        temp_limit_case (float): Maximum temperature of the case in Celsius. Defaults to 80.\n        soft_border_C_case (float): Soft border of the case in Celsius. Defaults to 5.\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ambient: float = 21,\n        params: Optional[dict[Any, Any]] = None,\n        temp_limit_windings: float = 115,\n        soft_border_C_windings: float = 15,\n        temp_limit_case: float = 80,\n        soft_border_C_case: float = 5,\n    ) -&gt; None:\n        # The following parameters result from Jack Schuchmann's test with no fans\n        if params is None:\n            params = {}\n        self.C_w: float = 0.20 * 81.46202695970649\n        self.R_WC = 1.0702867186480716\n        self.C_c = 512.249065845453\n        self.R_CA = 1.9406620046327363\n        self.\u03b1: float = 0.393 * 1 / 100  # Pure copper. Taken from thermalmodel3.py\n        self.R_T_0 = 65  # temp at which resistance was measured\n        self.R_\u03d5_0 = 0.376  # emirical, from the computed resistance (q-axis voltage/ q-axis current). Ohms\n\n        self.__dict__.update(params)\n        self.T_w: float = ambient\n        self.T_c: float = ambient\n        self.T_a: float = ambient\n        self.soft_max_temp_windings: float = temp_limit_windings - soft_border_C_windings\n        self.abs_max_temp_windings: float = temp_limit_windings\n        self.soft_border_windings: float = soft_border_C_windings\n\n        self.soft_max_temp_case: float = temp_limit_case - soft_border_C_case\n        self.abs_max_temp_case: float = temp_limit_case\n        self.soft_border_case: float = soft_border_C_case\n\n    def __repr__(self) -&gt; str:\n        return \"ThermalModel\"\n\n    def update(self, dt: float = 1 / 200, motor_current: float = 0) -&gt; None:\n        \"\"\"\n        Updates the temperature of the winding and the case based on the current and the ambient temperature.\n\n        Args:\n            dt (float): Time step in seconds. Defaults to 1/200.\n            motor_current (float): Motor current in mA. Defaults to 0.\n\n        Dynamics:\n            1: self.C_w * d self.T_w /dt = (I^2)R + (self.T_c-self.T_w)/self.R_WC\n            2: self.C_c * d self.T_c /dt = (self.T_w-self.T_c)/self.R_WC + (self.T_w-self.T_a)/self.R_CA\n        \"\"\"\n\n        I_q_des: float = motor_current * 1e-3\n\n        I2R = (\n            I_q_des**2 * self.R_\u03d5_0 * (1 + self.\u03b1 * (self.T_w - self.R_T_0))\n        )  # accounts for resistance change due to temp.\n\n        dTw_dt = (I2R + (self.T_c - self.T_w) / self.R_WC) / self.C_w\n        dTc_dt: float = ((self.T_w - self.T_c) / self.R_WC + (self.T_a - self.T_c) / self.R_CA) / self.C_c\n        self.T_w += dt * dTw_dt\n        self.T_c += dt * dTc_dt\n\n    def update_and_get_scale(self, dt: float, motor_current: float = 0, FOS: float = 1.0) -&gt; float:\n        \"\"\"\n        Updates the temperature of the winding and the case based on the current and\n        the ambient temperature and returns the scale factor for the torque.\n\n        Args:\n            dt (float): Time step in seconds.\n            motor_current (float): Motor current in mA. Defaults to 0.\n            FOS (float): Factor of safety. Defaults to 3.0.\n\n        Returns:\n            float: Scale factor for the torque.\n\n        Dynamics:\n            1: self.C_w * d self.T_w /dt = (I^2)R + (self.T_c-self.T_w)/self.R_WC\n            2: self.C_c * d self.T_c /dt = (self.T_w-self.T_c)/self.R_WC + (self.T_w-self.T_a)/self.R_CA\n        \"\"\"\n\n        I_q_des: float = motor_current * 1e-3\n\n        I2R_des = (\n            FOS * I_q_des**2 * self.R_\u03d5_0 * (1 + self.\u03b1 * (self.T_w - self.R_T_0))\n        )  # accounts for resistance change due to temp.\n        scale = 1.0\n        if self.T_w &gt; self.abs_max_temp_windings:\n            scale = 0.0\n        elif self.T_w &gt; self.soft_max_temp_windings:\n            scale *= (self.abs_max_temp_windings - self.T_w) / (\n                self.abs_max_temp_windings - self.soft_max_temp_windings\n            )\n\n        if self.T_c &gt; self.abs_max_temp_case:\n            scale = 0.0\n        elif self.T_c &gt; self.soft_max_temp_case:\n            scale *= (self.abs_max_temp_case - self.T_w) / (self.abs_max_temp_case - self.soft_max_temp_case)\n\n        I2R = I2R_des * scale\n\n        dTw_dt = (I2R + (self.T_c - self.T_w) / self.R_WC) / self.C_w\n        dTc_dt: float = ((self.T_w - self.T_c) / self.R_WC + (self.T_a - self.T_c) / self.R_CA) / self.C_c\n        self.T_w += dt * dTw_dt\n        self.T_c += dt * dTc_dt\n\n        if scale &lt;= 0.0:\n            return 0.0\n        if scale &gt;= 1.0:\n            return 1.0\n\n        return float(np.sqrt(scale))  # this is how much the torque should be scaled\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ThermalModel.update","title":"<code>update(dt=1 / 200, motor_current=0)</code>","text":"<p>Updates the temperature of the winding and the case based on the current and the ambient temperature.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>Time step in seconds. Defaults to 1/200.</p> <code>1 / 200</code> <code>motor_current</code> <code>float</code> <p>Motor current in mA. Defaults to 0.</p> <code>0</code> Dynamics <p>1: self.C_w * d self.T_w /dt = (I^2)R + (self.T_c-self.T_w)/self.R_WC 2: self.C_c * d self.T_c /dt = (self.T_w-self.T_c)/self.R_WC + (self.T_w-self.T_a)/self.R_CA</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def update(self, dt: float = 1 / 200, motor_current: float = 0) -&gt; None:\n    \"\"\"\n    Updates the temperature of the winding and the case based on the current and the ambient temperature.\n\n    Args:\n        dt (float): Time step in seconds. Defaults to 1/200.\n        motor_current (float): Motor current in mA. Defaults to 0.\n\n    Dynamics:\n        1: self.C_w * d self.T_w /dt = (I^2)R + (self.T_c-self.T_w)/self.R_WC\n        2: self.C_c * d self.T_c /dt = (self.T_w-self.T_c)/self.R_WC + (self.T_w-self.T_a)/self.R_CA\n    \"\"\"\n\n    I_q_des: float = motor_current * 1e-3\n\n    I2R = (\n        I_q_des**2 * self.R_\u03d5_0 * (1 + self.\u03b1 * (self.T_w - self.R_T_0))\n    )  # accounts for resistance change due to temp.\n\n    dTw_dt = (I2R + (self.T_c - self.T_w) / self.R_WC) / self.C_w\n    dTc_dt: float = ((self.T_w - self.T_c) / self.R_WC + (self.T_a - self.T_c) / self.R_CA) / self.C_c\n    self.T_w += dt * dTw_dt\n    self.T_c += dt * dTc_dt\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.ThermalModel.update_and_get_scale","title":"<code>update_and_get_scale(dt, motor_current=0, FOS=1.0)</code>","text":"<p>Updates the temperature of the winding and the case based on the current and the ambient temperature and returns the scale factor for the torque.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>Time step in seconds.</p> required <code>motor_current</code> <code>float</code> <p>Motor current in mA. Defaults to 0.</p> <code>0</code> <code>FOS</code> <code>float</code> <p>Factor of safety. Defaults to 3.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Scale factor for the torque.</p> Dynamics <p>1: self.C_w * d self.T_w /dt = (I^2)R + (self.T_c-self.T_w)/self.R_WC 2: self.C_c * d self.T_c /dt = (self.T_w-self.T_c)/self.R_WC + (self.T_w-self.T_a)/self.R_CA</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def update_and_get_scale(self, dt: float, motor_current: float = 0, FOS: float = 1.0) -&gt; float:\n    \"\"\"\n    Updates the temperature of the winding and the case based on the current and\n    the ambient temperature and returns the scale factor for the torque.\n\n    Args:\n        dt (float): Time step in seconds.\n        motor_current (float): Motor current in mA. Defaults to 0.\n        FOS (float): Factor of safety. Defaults to 3.0.\n\n    Returns:\n        float: Scale factor for the torque.\n\n    Dynamics:\n        1: self.C_w * d self.T_w /dt = (I^2)R + (self.T_c-self.T_w)/self.R_WC\n        2: self.C_c * d self.T_c /dt = (self.T_w-self.T_c)/self.R_WC + (self.T_w-self.T_a)/self.R_CA\n    \"\"\"\n\n    I_q_des: float = motor_current * 1e-3\n\n    I2R_des = (\n        FOS * I_q_des**2 * self.R_\u03d5_0 * (1 + self.\u03b1 * (self.T_w - self.R_T_0))\n    )  # accounts for resistance change due to temp.\n    scale = 1.0\n    if self.T_w &gt; self.abs_max_temp_windings:\n        scale = 0.0\n    elif self.T_w &gt; self.soft_max_temp_windings:\n        scale *= (self.abs_max_temp_windings - self.T_w) / (\n            self.abs_max_temp_windings - self.soft_max_temp_windings\n        )\n\n    if self.T_c &gt; self.abs_max_temp_case:\n        scale = 0.0\n    elif self.T_c &gt; self.soft_max_temp_case:\n        scale *= (self.abs_max_temp_case - self.T_w) / (self.abs_max_temp_case - self.soft_max_temp_case)\n\n    I2R = I2R_des * scale\n\n    dTw_dt = (I2R + (self.T_c - self.T_w) / self.R_WC) / self.C_w\n    dTc_dt: float = ((self.T_w - self.T_c) / self.R_WC + (self.T_a - self.T_c) / self.R_CA) / self.C_c\n    self.T_w += dt * dTw_dt\n    self.T_c += dt * dTc_dt\n\n    if scale &lt;= 0.0:\n        return 0.0\n    if scale &gt;= 1.0:\n        return 1.0\n\n    return float(np.sqrt(scale))  # this is how much the torque should be scaled\n</code></pre>"},{"location":"modules/#opensourceleg.actuators.deprecated_with_routing","title":"<code>deprecated_with_routing(alternative_func)</code>","text":"<p>Decorator to provide an alternative function for a deprecated function. The alternative function will be called instead of the deprecated function.</p> Source code in <code>opensourceleg/logging/decorators.py</code> <pre><code>def deprecated_with_routing(alternative_func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator to provide an alternative function for a deprecated function. The alternative function will be called\n    instead of the deprecated function.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            LOGGER.warning(\n                f\"Function `{func.__name__}` is deprecated. Please use `{alternative_func.__name__}` instead, \"\n                \"which will be called automatically now.\"\n            )\n            return alternative_func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"}]}